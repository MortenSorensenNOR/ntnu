\documentclass[a4paper,11pt,norsk]{article}
\usepackage{tikz}
\usepackage{babel}
\usepackage{xcolor}
\usepackage{minted}
\usepackage{a4wide}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{siunitx}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{enumitem}
\usepackage{tcolorbox}
\usepackage{algorithm}
\usepackage{algpseudocode}

\title{Complexity Analysis of RSA Architecture}
\date{}

\begin{document}
\maketitle

This document outlines the time and compute complexity of the algorithm used 
in our RSA architecture based on the Montgomery method.
The complexities will be given in terms of the number of additions, subtractions,
etc. that are required to perform the given algorithm with a given bit width $k$.


\subsection*{Blakley Modular Multiplication}
Used to compute $A \cdot B \mod{(n)}$. 
The algorithm is as follows:

\begin{algorithm}
\caption{BlakleyModPro(A, B, n, k) = $A \cdot B \mod{(n)}$}
\begin{algorithmic}
    \State $u = 0$
    \For{$i = 0$ to $k-1$}
        \State $u = 2u$
        \If{carry-out}
            \State $u = u + m$
        \EndIf
        \State $u = u + A \cdot B_{k-1-i}$
        \If{carry-out}
            \State $u = u + m$
        \EndIf
    \EndFor
    \State \Return $u$
\end{algorithmic}
\end{algorithm}

where $m = 2^k - n$. This algorithm requires possibly $3k$ additions of size $k$ and $k$ 
bit-shifts, but we will not count the bit-shifts as they can be done very efficiently
in hardware.
\[
    \text{Complexity(Blakley)} = 3k \cdot \text{Add}(k)
\]

\subsection*{Montgomery Modular Multiplication}
Used to compute $A \cdot B \cdot r^{-1} \mod{(n)}$. The algorithm is as follows:
\begin{enumerate}
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \item $u = 0$
    \item \textbf{for} $i = 0$ to $k-1$ \textbf{do}
    \item \hspace{0.75cm} $u = u + A_i \cdot B$
    \item \hspace{0.75cm} \textbf{if} $u = 1 \mod{(2)}$ \textbf{then} $u = u + n$
    \item \hspace{0.75cm} $u = u / 2$ 
    \item \textbf{end for}
    \item \textbf{return} $u$
\end{enumerate}

This algorithm requires up to $2k$ additions of size $k$. The division by 2 and the 
multiplication of $A_i$ and $B$ can be done with a bit-shift and a mux respectively,
and checking if $u$ is odd can be done in parallell with the first addition, and so 
does not give a complexity penalty.

\[
    \text{Complexity(MonMul)} = 2k \cdot \text{Add}(k)
\]

\subsection*{Montgomery Modular Exponentiation}
Used to compute $M^e \mod{(n)}$. The algorithm is as follows:
\begin{enumerate}
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \item $\bar{x} = r \mod{(n)}$   \hspace{5cm}// Can be precomputed
    \item $\bar{M} = M \cdot r \mod{(n)}$ \hspace{4.1cm}// Using Blakley

    \item \textbf{for} $i = k-1$ to $0$ \textbf{do}
        \item \hspace{0.75cm} $\bar{x} = \text{ MonPro}(\bar{x}, \bar{x})$
        \item \hspace{0.75cm} \textbf{if} $e_i = 1$ \textbf{then} 
        \item \hspace{1.5cm}  $\bar{x} = \text{ MonPro}(\bar{M}, \bar{x})$
        \item \hspace{0.75cm} \textbf{end if}
    \item \textbf{end for}

    \item $x = \text{ MonPro}(\bar{x}, 1)$
    \item \textbf{return} $x$
\end{enumerate}

We see here that the algorithm uses one Blakley multiplication, and $2k$ Montgomery
multiplications. The total complexity of this algorithm is therefore
\begin{align*}
    \text{Complexity(MonExp)} &= \text{Blakley} + 2k \cdot \text{Montgomery} + \text{Montgomery}\\
                      &= 3k \cdot \text{Add}(k) + k \cdot 4k \cdot \text{Add}(k) \\
                      &= (5k + 4k^2) \cdot \text{Add}(k)
\end{align*}


Given $e = 2^{16} + 1$
\[
    (2 * 17 + 1) * MonPro
\]

\end{document}
